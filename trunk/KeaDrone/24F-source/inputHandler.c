/*
 * inputHandler.c
 *
 *  Created on: 24 nov 2009
 *  Author	: W.N. Pietersz
 *	Website	: www.wnpd.nl
 */
#include "compiler.h" // auto select the right header
#include "inputHandler.h"

/* The input is active low, default is  high */
#define INPUT_PRESSED	1
#define INPUT_RELEASED	0
#define MS_SCAN_TIME	10

#define DELAY_DENDER	1
#define DELAY_PRESS_SHORT 	99
#define DELAY_PRESS_LONG 	100

#define DELAY_RELEASED_SHORT 	99
#define DELAY_RELEASED_LONG 	100

/* If you have less than 8 inputs you can use UINT8,
 * less than 16 UINT16 - less than 32 UINT32..... */
typedef UINT16 REG_BIT_SIZE;
static REG_BIT_SIZE inputStatus = 0;

/**************** Circular buffer part *****************/
#define EV_BUFFER_SIZE 20

typedef struct
{
	/* struct for a circular FIFO buffer*/
	INT16 evIn; /* head of the buffer*/
	INT16 evOut; /* tail of the buffer*/
	INT16 evSize;
	INPUT_EV_ID evId[(EV_BUFFER_SIZE + 1)];
	INPUT_EV_TYPE evType[(EV_BUFFER_SIZE + 1)];
} EVENT_BUFFER_QUEUE_TYPE;

EVENT_BUFFER_QUEUE_TYPE EventBuf =
{ 0 };

/* Retruns true if new event, else false*/
BOOL inputEventGet(INPUT_EV_ID *evId, INPUT_EV_TYPE *evType)
{
	if (EventBuf.evSize != 0)
	{
		// copy from buffer
		*evId = EventBuf.evId[EventBuf.evOut];
		*evType = EventBuf.evType[EventBuf.evOut];

		// de-credement the buffer size since we used one
		EventBuf.evSize--;
		/* point the tail of buffer to next element*/
		if (EventBuf.evOut >= EV_BUFFER_SIZE)
			EventBuf.evOut = 0;
		else
			EventBuf.evOut++;
		return TRUE;
	}
	return FALSE;
}

/* Returns false if full else true*/
static BOOL inputEventPut(INPUT_EV_ID evId, INPUT_EV_TYPE evType)
{
	/* check that buffer is not full*/
	if (EventBuf.evSize <= EV_BUFFER_SIZE)
	{
		EventBuf.evId[EventBuf.evIn] = evId;
		EventBuf.evType[EventBuf.evIn] = evType;

		// de-credement the buffer size since we used one
		EventBuf.evSize++;
		/* point the head of buffer to next element*/
		if (EventBuf.evIn >= EV_BUFFER_SIZE)
			EventBuf.evIn = 0;
		else
			EventBuf.evIn++;
		return TRUE;
	}
	return FALSE;
}

void inputEvClear(void)
{
	/* create on the stack only*/
	EVENT_BUFFER_QUEUE_TYPE EventBufClr =
	{ 0 };
	/* Clear the event buffer*/
	EventBufClr = EventBuf;
}
/**************** END Circular buffer  *****************/

/* the event handler of the inputs */
static void inputEvent(UINT8 swNumber, INPUT_EV_TYPE EV_STATE)
{
#ifdef NOT_NECC
	static UINT8 delayId = 0;
	static BOOL keypadInitialized = FALSE;

	/* On first power-up, (1)we do not want to receive any events since
	 * the device needs to stabilize first and (2) because the
	 * the inputHandler will always generate events because some ports
	 * uses a default hardware state of logic '1' or logic state '0'
	 * when a key is not pressed. This definitely can be done better (todo)	 */
	if (keypadInitialized == FALSE)
	{
		/* Only execute on a regular basis*/
		if (!(ucDelayMs(DELAY_PRESS_LONG + 1000, &delayId)))
		return;
		else
		keypadInitialized = TRUE;
		/* A better way can be: to put inside the inputPoller:
		 * Initialize all delayCounters to their power-on-value
		 * so events will not be generated if they are logic high when not-pressed
		 */
	}
#endif
	/*  This application does not need to know when a key is released*/
	/*	if (EV_STATE == KP_EV_SETOFF || EV_STATE == KP_EV_SETOFF_CONTINOUS
	 || EV_STATE == KP_EV_SETOFF_LONG || EV_STATE == KP_EV_SETOFF_SHORT)
	 {
	 return;
	 }*/
	inputEventPut(swNumber, EV_STATE);
#ifdef Choose best option
	switch (EV_STATE)
	{
		case KP_EV_SETON_SHORT:

		break;
		case KP_EV_SETON_LONG:

		break;
		case KP_EV_SETON_CONTINOUS:

		break;

		case KP_EV_SETOFF_SHORT:

		break;
		case KP_EV_SETOFF_LONG:

		break;
		case KP_EV_SETOFF_CONTINOUS:

		break;
	}
#endif
}

#define NUMBER_OF_BITS_TO_SCAN 16

/* used for the inputHandler to determine the input status
 * This function need to be ported for every application
 * The input param. will be generated by the input-scanner
 * So if it asks bit no. 2, you will return if this bit no.2
 * is high or low. The input handler will do the rest like anti-dender
 * and determine if it is a short, long or continuously pressed button
 * */
static BOOL portGetLiveInput(REG_BIT_SIZE inputbit)
{
	BOOL eStatus = 0;

	// the input data comes from diff. reg. so we choose the right one here
	if (inputbit < (1 << 6))
	{
		/* we have user-keypad:6x*/
		// PORTF input starts from RF0
		eStatus = (PORTB & (inputbit));
		/* inputs are logic LOW = TRUE */
		eStatus = !eStatus;
	}
	else if (inputbit < (1 << (6 + 6)))
	{
		/* we have paal isolated:3x
		 * we have paal non-isolated: 3x*/
		// PORTD inputs starts from RD1, so offset: <<1 minus the offset of inputbit
		eStatus = (PORTD & (inputbit >> (5)));

		/* All inputs are inverted (logic low means pressed) */
		//if ((inputbit >> (5)) <= 0xF)
		eStatus = !eStatus;
	}
	else// if (inputbit < (1<<6+6+4))
	{
		/* we have config-keypad:*/
		/* PORTB input starts from RF10
		 * minus the offset of inputbit minus RB10 << 10;
		 */
		eStatus = (PORTB & (inputbit >> (6 + 6 - 10)));
		/* inputs are logic HIGH = TRUE */
		eStatus = !eStatus;
	}
	if (eStatus)
		eStatus = TRUE;
	return eStatus;
}

/* Must be called continuous
 * Fires an event when:
 * Key is sensed as a press/release
 * Key is sensed as a short/long or continuous press/release
 *
 * So it will ALWAYS fire 2 events when pressed/released
 * */
void pollScanInputs(void)
{
	// variable to store the time that a key is pressed
	static UINT8 pressedDelayCounter[NUMBER_OF_BITS_TO_SCAN] =
	{ 0 };
	static UINT8 releasedDelayCounter[NUMBER_OF_BITS_TO_SCAN] =
	{ 0 };
	static UINT8 delayId = 0;
	UINT8 swNumber;
	REG_BIT_SIZE scanBIT;

	/* Only execute on a regular basis*/
	if (!(ucDelayMs(MS_SCAN_TIME, &delayId)))
		return;

	// PORTbits < x --> x = number of bits to scan
	for (swNumber = 0; swNumber < NUMBER_OF_BITS_TO_SCAN; swNumber++)
	{
		scanBIT = (1 << swNumber);

		switch (portGetLiveInput(scanBIT))
		{
		case INPUT_PRESSED:
			// if input is pulled low (default state is high)

			/* We check if the buttun was last NOT__PRESSED, if true
			 * we need to check what kind of event is was */
			if (!(inputStatus & scanBIT))
			// the input is SET confirmed
			{
				// was it a magic pulse?*dender*
				if ((releasedDelayCounter[swNumber]) < DELAY_DENDER)
					;
				else if ((releasedDelayCounter[swNumber])
						< DELAY_RELEASED_SHORT)
					inputEvent(swNumber, KP_EV_SETOFF_SHORT);

				else if ((releasedDelayCounter[swNumber]) < DELAY_RELEASED_LONG)
					inputEvent(swNumber, KP_EV_SETOFF_LONG);
			}

			releasedDelayCounter[swNumber] = 0;
			inputStatus |= scanBIT;

			if ((pressedDelayCounter[swNumber]) < DELAY_PRESS_LONG)
			{
				pressedDelayCounter[swNumber]++;
				if ((pressedDelayCounter[swNumber]) == (DELAY_DENDER + 1))
					/* we fire an event already now since we might just
					 * want to know when pressed or not */
					inputEvent(swNumber, KP_EV_SETON);
			}
			// pressed delay timer reached?
			else if ((pressedDelayCounter[swNumber]) == DELAY_PRESS_LONG)
			// confirm the input
			{
				inputEvent(swNumber, KP_EV_SETON_CONTINOUS);
				// increment once so this event only happens
				// once
				pressedDelayCounter[swNumber]++;
			}

			break;

		case INPUT_RELEASED:

			if ((inputStatus & scanBIT))
			// the input is not yet SET confirmed
			{
				// was it a magic pulse?
				if (pressedDelayCounter[swNumber] < DELAY_DENDER)
					;
				// was it a short button press?

				else if (pressedDelayCounter[swNumber] < DELAY_PRESS_SHORT)
					// pressed short delay timer reached?
					// SET the status
					inputEvent(swNumber, KP_EV_SETON_SHORT);
				// was it a long press?

				else if (pressedDelayCounter[swNumber] < DELAY_PRESS_LONG)
					inputEvent(swNumber, KP_EV_SETON_LONG);
				// if it was a continuous press, the event is already handled
			}

			// input is high (default state)
			pressedDelayCounter[swNumber] = 0;
			inputStatus &= ~(scanBIT);

			if ((releasedDelayCounter[swNumber]) < DELAY_RELEASED_LONG)
			{
				releasedDelayCounter[swNumber]++;
				if ((releasedDelayCounter[swNumber]) == (DELAY_DENDER + 1))
					/* we fire an event already now since we might just
					 * want to know when pressed or not */
					inputEvent(swNumber, KP_EV_SETOFF);
			}
			else if ((releasedDelayCounter[swNumber]) == DELAY_RELEASED_LONG)
			{
				// CLEAR the action status
				inputEvent(swNumber, KP_EV_SETOFF_CONTINOUS);
				releasedDelayCounter[swNumber]++;
			}

			break;
		}
	}
}

static void portInputInit(void)
{
	/* we have paal isolated:3x
	 * CN50/RD1
	 * CN51/RD2
	 * CN52/RD3
	 * we have paal non-isolated: 3x
	 * CN13/RD4
	 * CN14/RD5
	 * CN15/RD6
	 * Make them inputs:
	 * */
	TRISD |= 0x7E;
	//pull ups
	_CN50PUE = TRUE;
	_CN51PUE = TRUE;
	_CN52PUE = TRUE;
	/* */
	_CN13PUE = TRUE;
	_CN14PUE = TRUE;
	_CN15PUE = TRUE;
	//_CN13PDE = TRUE;
	//_CN14PDE = TRUE;
	//_CN15PDE = TRUE;
	/* Why not remove the external resistor and use internal res?*/
	/* we have user-keypad:6x
	 * CN58/RF0
	 * CN59/RF1
	 * CN60/RF2
	 * CN61/RF3
	 * CN62/RF4
	 * CN63/RF5
	 * Make them inputs
	 */
	TRISB |= 0x3F;
	// pull ups
	_CN2PUE = TRUE;
	_CN3PUE = TRUE;
	_CN4PUE = TRUE;
	_CN5PUE = TRUE;
	_CN6PUE = TRUE;
	_CN7PUE = TRUE;

	/* we have config-keypad: 4x (ALL SHARED WITH ANALOG)
	 * CN28/RB10
	 * CN29/RB11
	 * CN30/RB12
	 * CN31/RB13
	 * CAUTION! MUST ENABLE PULL-UP'S FOR PROPER READINGS
	 */
	TRISB |= ~0x3C00;
	_CN28PUE = TRUE;
	_CN29PUE = TRUE;
	_CN30PUE = TRUE;
	_CN31PUE = TRUE;

}

void inputInit(void)
{
	inputEvClear();
	portInputInit();
}
